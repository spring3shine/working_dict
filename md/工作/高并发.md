# 高并发



- 多线程
- 多进程
- 多机（分布式）
- 锁
- 协程

---

## 线程池

参数

- 核心数
- 最大数
- keepAliveTime（超过核心数时的回收）
- 队列（注意长度）
  - 最大容量默认应该Integer.MAX_VALUE
  - 通常自定义长度
- 拒绝策略
  - 直接抛弃
    - 报异常
    - 不报异常继续执行
  - 丢弃队列中最老的，然后加入队列
  - 不进入线程池，让原线程执行操作





## 锁

类型

- 悲观锁 & 乐观锁：线程获取临界资源前，要不要对资源直接加锁
  - 直接加：悲观锁
    - 适合写操作多
  - 不加：乐观锁 
    - 比如：AutomicInteger
    - 等到要更新数据时，先判断数据是不是更新过了，如果没有，就进行操作；否则报错或者重试
    - 适合读操作多
    - 实际上通过无锁算法CAS实现（Compare And Swap）原子操作
    - CAS问题
      - ABA :  无法感知到变化，引入版本号可以解决1A-2B-3A（AtomicStampedReference）
      - 循环开销大：CAS长时间不成功（大量写），会一直自旋，空耗CPU
      - 只能保证一个共享变量的原子性：（AtomicReference可以把多个变量放在一个对象里进行CAS操作）
- 自旋锁 & 自适应自旋锁：拿锁失败，怎样做系统调度
  - 非自旋：开锁失败，让线程休眠放开CPU占用，等锁释放后再尝试
  - 自旋：开锁失败，不放弃CPU时间片，通过自旋等待锁释放
  - 自适应自旋锁：统计一段资源的锁自旋成功率，成功率越高，系统认为这次自旋越可能成功，允许自旋更长的时间
  - 排号自旋锁：FIFO，先进先出
  - CLHLock
  - MCSLock
- 锁状态，专门针对synchronized的
  - 无锁  ：比如CAS的无锁算法
  - 偏向锁 （默认）：一直被被一个线程使用，该线程自动获取锁，而不用重复CAS拿锁操作
  - 轻量级锁  ：第二个线程竞争，在当前线程从偏向锁升级为轻量级锁，第二个线程自旋等待(不阻塞，避免唤醒调度的开销)
  - 重量级锁：继续加线程，等待锁的线程都会进入阻塞状态
- 公平锁&非公平锁：多个线程的排队
  - 公平锁：排队
  - 非公平锁：锁刚好释放，那就插队，否则乖乖排队（减少一次唤醒操作）
  - ReentrantLock
- 可重入锁 & 不可重入锁
  - 可重入锁：
    - ReentrantLock、Synchronized 
    - 一定程度上避免死锁（自己试着拿自己的锁）
  - 非重入锁：
    - NonReentrantLock
- 共享锁 & 独享锁（排他锁）
  - 独享锁（排他锁）：synchronized，Lock
  - 共享锁 : 只能读数据，不能修改数据。

---

算法：

AQS: AbstractQueuedSynchronizer，抽象同步队列

- 维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列

- state，初始为0，拿到锁+1，可重入锁继续+1，释放锁-1，锁为0时即完全释放
- 主要方法
  - isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。
  - tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。
  - tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。
  - tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
  - tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。

![img](https://images2015.cnblogs.com/blog/721070/201705/721070-20170504110246211-10684485.png)





---



Java实现

- synchronized 对象内存锁，Java底层实现

  - 每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。

    ```我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。
    我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。
    
    Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。
    
    Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
    ```

  - 对象存储空间里有一块内容存储这个锁的信息，比如：有没有被占用？被谁占用？...

  - 用法

    - 修饰实例方法 - 锁该实例对象
    - 修饰静态方法-  锁当前类的 class 对象
    - 修饰代码块
      - 成员锁: sychronized(o1){ }
      - 实例对象锁：synchronized(this){ }
      - 类级别的锁:  synchronized(AccountingSync.class) { }

- volatie 易变变量
  
  - 每个线程存储变量的内存副本，volatie表示不适用副本直接使用主内存，所以所有线程可见
  - 但不是原子性的
  
- wait() & notify() & notifyAll() & yeild()

  - 只有synchronized块才能调用wait()，
  - yuild()功能和wait()很像，但不放锁，基本没啥用



## 锁问题

- 什么情况下会出现死锁？
  - 临界资源竞争，AB互相持有一部分，并且同时等待对方的一部分

