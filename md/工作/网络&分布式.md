

# 计算机网络

## ip/tcp  http

### ip协议

首部+数据部分 （ip层协议，负责网络传输端到端）

- 首部：
  - IP协议版本 - IPV4
  - 头部长度
  - 服务质量，重要度
  - 网络包总长度
  - 分包
    - 子包分段标志2个，用于路由器节点按自己的硬件质量分包
      - 第几个包
      - 可否细分
    - 分段偏移量
  - TTL , 路由跳数
  - 协议：https之类的上层协议
  - 头部校验和：校验完整性
  - 源ip
  - 目标ip

### tcp协议

- tcp 传输层
- tcp 是对应用层数据进行切分用的
- 为了保证数据完整和有序，每个分包有序号
- 源端口
- 目标端口
- 报文序号
- 应答号：期望收到的数据段序号，这样就能确认收到报文了
- tcp首部长度
- 保留位
- 标记
  - ACK
  - SYN
  - FIN
  - ...
- 窗口大小：机器缓冲区还剩多少
- 校验和
- 可配置项：维护网络质量，比如扩大窗口，规定切片大小等

### http协议

- http 应用层



### 一些协议的问题和关系：

- ip层的核心是是1.信息包的传送2.包的分割重组，不关心内部数据准确性也没办法关心（所以只有头部校验）
- tcp是为了保证数据准确上提高网络质量，
  - 校验
  - MD5加密
  - 超时重传
  - 滑动窗口
  - TCP拥塞控制算法
    - 慢启动
    - 拥塞避免
    - 快速重传
    - 快速恢复
- 为什么IP层会分片，TCP还要分段？
  - tcp分片比ip分片小很多，这样当一个ip分片错误时，它只需要重传一小段tcp分片就可以了
- http协议在tcp协议之上
  - http基于tcp建立
  - 默认http建立之后就把tcp给关了，所以tcp有状态，http无状态
  - 如果http开启了keep-alive，就不会关tcp，而是保持有状态的长连接，直到客户端声明断开Connection: close
- 一个tcp连接可以建立多少个http请求？
  - 只要不断开，就能持续请求
- 一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？
  - http/1.1 单个tcp中http请求生命周期不能重叠
  - http/2 中提供了Multiplexing 多路传输技术，可以同时请求
- 为什么有的时候刷新页面不需要重新建立 SSL 连接？
  - TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。
- 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？
  - 有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接，不同的浏览器有一些区别。
- 一台机器最大究竟能支持多少个网络连接？
  - 考虑TCP-4元（源ip、目标ip、源端口、目标端口）
  - **TCP连接的客户端机：**每一个ip可建立的TCP连接理论受限于ip_local_port_range参数，也受限于65535。但可以通过配置多ip的方式来加大自己的建立连接的能力。
    **当Linux作为客户端建立连接的时候，最大连接数量是受内核参数net.ipv4.ip_local_port_range限制** 而ip_local_port_range是可配置的，最大理论范围是0-65535
  - **TCP连接的服务器机：**每一个监听的端口虽然理论值很大，但这个数字没有实际意义。最大并发数取决你的内存大小，每一条静止状态的TCP连接大约需要吃3.3K的内存。

---

## 网络建立连接的流程

> 若收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？

1、 如果图片都是 **HTTPS 连接并且在同一个域名**下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 **HTTP2**，如果能的话就使用 Multiplexing 功能在这个连接上进行**多路传输**。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。

2、 如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 **HTTP2** 都是**在 HTTPS 上实现**的，所以也就是只能使用 **HTTP/1.1**）。那浏览器就会在**一个 HOST 上建立多个 TCP 连接**，连接数量的**最大限制取决于浏览器设置**，这些连接会在空闲的时候被浏览器用来发送新的请求，若所有的连接都正在发送请求，那么其他的请求就只能等待。

---

## 劫持

- https 劫持
  - cookies
  - 账户密码
- DNS 劫持
  - 篡改DNS请求，定位到攻击者的DNS服务器，然后后续请求就能被处理
    - 使用DNS高级协议
  - 攻击路由器
    - 管理好路由器
  - 修改本地pac文件
    - 管理好本机

----

## 分布式 CAP 理论

任何一个分布式系统都无法同时满足，最多只能同时满足两项。（模型更像是三角能力图，而不是三个二极管）

1. 一致性（Consistency）,
   1. 所有节点数据一致（考虑数据同步机制）
   2. 强一致 or 最终一致
2. 可用性（Availability）
   1. 所有节点都可以用来满足业务需求
   2. 业务需求100ms，节点不能100s返回数据
   3. 节点数据即使有问题，也要返回请求
   4. 系统部分宕机不影响系统正确使用
3. 分区容错性（Partition tolerance）
   1. 网络通信出现问题，不能影响系统正确使用
   2. P出现问题概率很低，但一定会出现



AP or CP

- 考虑到网络延迟，一致性往往需要时间成本，所以分布式系统多AP方式



几个问题

- 为什么C和A冲突？
  - 要一致性，那么在数据同步过程中，一定是不可用的

- 服务注册中心，是选择AP还是选择CP ？
  - 数据不一致性在注册服务中中会给eureka带来什么问题，无非就是某一个节点被注册的服务多，某个节点注册的服务少，在某一个瞬间可能导致某些ip节点被调用数少，某些ip节点调用数少的问题。也有可能存在一些本应该被删除而没被删除的脏数据。
  - zookeeper选择CP
    即任何时刻对zookeeper的访问请求能得到一致性的数据结果，同时系统对网络分割具备容错性，但是它不能保证每次服务的可用性。从实际情况来分析，在使用zookeeper获取服务列表时，如果zk正在选举或者zk集群中半数以上的机器不可用，那么将无法获取数据。所以说，zk不能保证服务可用性。
  - eureka选择AP
    eureka在设计时优先保证可用性，每一个节点都是平等的，一部分节点挂掉不会影响到正常节点的工作，不会出现类似zk的选举leader的过程，客户端发现向某个节点注册或连接失败，会自动切换到其他的节点，只要有一台eureka存在，就可以保证整个服务处在可用状态，只不过有可能这个服务上的信息并不是最新的信息。

- 分布式锁，是选择AP还是选择CP ？
  - 看业务对同步的要求
  - 基于redis实现分布式锁
    - redis采用了AP模型，主从节点数据不是实时同步的，有同步的相关配置
  - 基于zookeeper实现分布式锁
    - ZK 采用CP模型，但并不支持分布式锁的直接实现

- 分布式事务，银行跨行转账怎么搞？
  - Saga，将长事务拆分成多个短事务
    - 业务必须满足条件：不能取消回滚（因为不支持回滚）
  - TCC (try-confirm-cancel)
    - Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）
    - Confirm 阶段：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作要求具备幂等设计，Confirm 失败后需要进行重试。
    - Cancel 阶段：取消执行，释放 Try 阶段预留的业务资源。Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致，要求满足幂等设计。
    - TCC的Confirm/Cancel阶段在业务逻辑上是不允许返回失败的，如果因为网络或者其他临时故障，导致不能返回成功，TM事务管理器会不断的重试，直到Confirm/Cancel返回成功。
    - TCC适用于订单类业务，对中间状态有约束的业务
  - 本地消息表
    - A -> MQ -> B
    - 核心在于A中操作执行后，mq消息一定要发出去
    - 一张存放本地消息的表，一般都是放在数据库中，然后在执行业务的时候 **将业务的执行和将消息放入消息表中的操作放在同一个事务中**，这样就能保证消息放入本地表中业务肯定是执行成功的。
    - A流程失败，可以直接回滚
    - B不允许失败，要一直尝试直到成功（因为A无法回滚了）
    - 适用于可异步执行的业务，且后续操作无需回滚的业务

---

分布式共识算法

- 哨兵机制
  - 