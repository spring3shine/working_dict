# Java





## Java 类生命周期

![image-20200827153624097](https://tva1.sinaimg.cn/large/007S8ZIlly1gi5eqpkg4cj312m0dyjvn.jpg)

- 加载流程
  - 加载.class二进制字节流
  - 将字节流对应的静态结构转存如方法区
  - 在堆区生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
- 链接
  - 验证：校验字节码的有效性
  - 准备：为类的静态变量分配内存，并将其初始化为默认值（方法区）
  - 解析：把类中的符号引用转换为直接引用
- 初始化：对类的静态变量，静态代码块执行初始化操作 （如果一个类没有初始化并尝试调用，就触发双亲委派加载）
- 使用：创建实例
- 卸载：程序各种情况结束





**类加载器**

- 双亲委派：

  ![image-20200827135310660](https://tva1.sinaimg.cn/large/007S8ZIlly1gi5brab180j31iy0m87qk.jpg)

- 优点
  
  - 防止用户破坏核心API
- 破坏
  - JDBC
    - java.sql.Driver只是一个接口，它依赖于各数据库的实现jar包，但Java不可能让mysql.driver写到JDK里，所以只能通过SPI加载了
  - 热部署：
    - JVM不做：因为**复杂度高并且没有太高的回报**。
    - **单个ClassLoader无法多次加载相同标识的class**（涉及到GC、内存分配、运行时线程安全）
    - **定义不同的ClassLoader**，监听文件变化后，通过新的ClassLoader加载新文件，然后做好相应的状态恢复，对旧ClassLoader进行卸载等动作。Tomcat的动态部署其实就是监听war变化，然后调用StandardContext.reload()，用新的WebContextClassLoader实例来加载war，然后初始化servlet来实现。类似的实现还有OSGi等。



**SPI类加载技术**

- SPI 全称为Service Provider Interface，是一种服务发现机制。
- SPI 的本质是：将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。
- 这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。







## 虚拟机

​	![img](https://upload-images.jianshu.io/upload_images/23383522-a042084fbecd8653.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)





## OOM (out of memery)

- 内存泄漏：查看异常对象的引用链

- 内存溢出：修改JVM堆参数 -Xms



## 垃圾回收

标记

- 引用计数，无法处理循环引用

- 根搜索算法，根：

  - 栈帧中的本地变量表

  - 方法区中常量引用的对象；

  - 方法区中静态属性引用的对象；

  - 本地方法栈中 JNI（Native 方法）引用的对象；

  - 活跃线程

  - ```
    1、进行根搜索的时候，是需要暂停所有线程的，即执行一次 STW（Stop The World），最主要的目的是防止上述的对象图在算法运行的过程中有变化从而影响算法的准确性。
    2、线程暂停的时间长短，取决于对象的多少，和堆内存的大小无关。
    3、 宣告一个对象的“死亡”其实不仅仅通过上述的算法计算，而是需要经历两次的标记，本文暂不进行赘述。
    ```

回收：

- **标记-清除算法**：有内存碎片
- **标记-整理算法**: 可以整理掉内存碎片
- **复制算法** ：新生代
  - 内存分为两块，创建对象的时候，只使用其中的一块区域（例如S0），当S0使用完之后，便将S0上面存活的对象全部复制到S1上面去，然后将S0全部清理掉。
  - 不会产生内存碎片；
  - 标记和复制可以同时进行，只对存活对象复制，所以效率高(死对象多)
  - 但内存使用率低下
- **适应性算法**：根据堆内存具体的使用情况而自动选用更适合当前情况的回收算法。



分代回收：

- 新生代：标记-复制
- 老生代：标记-整理
- 永生代：



回收的范围：

- Scavenge GC：新生代

- Full-GC：整个堆内存

触发 GC 条件：

- 应用程序空闲时
- 堆内存不足的时候（如果GC都无法腾出有效空间就会OOM）

Full-GC触发条件：

- 新生代空间不足，尝试放老年代，但老年代空间也不足
- 新生代因为老年代空间不足而晋升失败
- 老年代无法容纳下次新生代晋升(统计平均)

减少GC:

- 不要显式调用 `System.gc()`。

- 减少临时对象的使用
- 对象不用时最好显式置为 Null。一般而言，为 Null 的对象都会被作为垃圾处理
- 尽量使用 StringBuilder 来代替 String 的字符串累加。
- 允许的情况下尽量使用基本类型（如 int）来替代 Integer 对象。
- 合理使用静态对象变量。





## JVM调优

- jmap -dump
- jprofile查看分析dump文件 


